### 竞态 
- 先检查后执行 和 读取-修改-写入 等复合操作必须是原子的。重点是`复合操作`，一系列的动作都要满足原子性，这个结果才会返回正确。要保持状态一致性，就需要在单个原子操作中更新所有相关的状态变量


### 方法
- 静态`synchronized`方法，是以`Class`对象作为锁，修饰的函数同一时刻只有一个线程可以执行。性能比较差,并且不可以重入.

### 2.4 使用锁保护状态


### 3.1 内存可见性
读操作和写操作在不同线程，互相见到的变量是不相同的。

#### 3.1.3 加锁和可见性
对于同一个锁的所有操作，A线程进行的操作，对B线程是可见的。
例如
```A: lock M;i+=1;unlock M ;
B: lock M; a = i; unlock M;
```

#### 3.1.4 volatile变量
- 不会将volatile变量进行重排
- 不同线程对volatile变量进行的操作都可见
- 不建议过分依赖volatile变量
- 典型用法：检查某个标记是否退出循环
```
volatile boolean ready;
while (!ready){
    doSth();
}
```
